---
title: "Introduction to Design of Experiments (DoE)"
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| include: false

library(tidyverse)
library(SixSigma)
library(gt)
library(broom)
library(qqplotr)
library(ggeffects)
library(here)
library(ggDoE)
library(vroom)
library(gtsummary)
library(patchwork)
library(qqplotr)
library(ggrepel)
library(SensorLab)
library(rstatix)
library(gt)
library(FrF2)

ggplot2::theme_set(
  ggthemes::theme_few(base_size = 15)
  )

```

## (O)ne (F)actor (A)t a (T)ime


```{r}
#| label: fig-ofat
#| out-width: 95%
#| fig-cap: OFAT quickly becomes cumbersome


ofat <- expand_grid(
  no_lvls = seq(2,10,0.01),
  no_var = seq(2,4)
) |> 
  mutate(
    no_exp = no_lvls^no_var,
    no_var = no_var |> as_factor()
  )

ofat |> 
  ggplot(
    aes(
      x = no_lvls,
      y = no_exp,
      # color = no_var,
      linetype = no_var
    )
  )+
  geom_line()+
  theme_classic(
    base_size = 15
  )+
  scale_x_continuous(
    breaks = seq(2,10,1)
  )+
  scale_y_continuous(
    breaks = c(100,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000)
  )+
  labs(
    title = "OFAT number of experiments",
    x = "number of factor levels",
    y = "number of experiments",
    linetype = "number of factors\n(investigated variables)"
  )+
  theme(
    legend.position = "bottom"
  )

```

## curse of dimensionality

\begin{align}
n_{experiments} = n_{levels}^{n_{factors}}
\end{align}

## Concept of ANOVA

```{r}
#| label: fig-ANOVA-01
#| out-width: 75%
#| fig-cap: classical ANOVA concept

knitr::include_graphics(here::here("chapter005","025_ANOVA_nd.png"))

```

## Basics of Experimental Design

```{r}
#| label: fig-DoE-01
#| out-width: 95%
#| fig-cap: The connection between ANOVA and DoE.

knitr::include_graphics(here::here("chapter005","ANOVA_DoE.png"))

```

::: {.content-visible when-profile="script"}

{{< acr DoE >}}

:::

## Terminology

- Factors (X’s): Independent variables (e.g., temperature, pressure, catalyst concentration).
- Levels: Values a factor can take (e.g., low/high temperature).
- Response (Y): Dependent variable (e.g., yield, defect rate).
- Treatment: A specific combination of factor levels.
- Replication: Repeating a treatment to estimate error.
- Randomization: Assigning treatments randomly to reduce bias.
- Blocking: Grouping similar experimental units to control nuisance variables.

## Key Concepts

- Factorial Designs: Study all combinations of factor levels (e.g., $2^2 = 4 \text{runs}$ for $2$ factors at $2$ levels).
- Main Effects vs. Interactions:
    - Main effect: Change in response due to one factor (e.g., increasing temperature increases yield).
    - Interaction: Effect of one factor depends on another (e.g., temperature and pressure interact to affect yield).


- Orthogonality: Factors are uncorrelated (balanced designs).

## DoE Types

### Full Factorial

- All possible combinations of factor levels are tested.
- Example: 2 factors (A, B) at 2 levels → 4 runs ($2^2$).
- Pros: Estimates all main effects and interactions.
- Cons: Exponential growth in runs (e.g., 5 factors at 2 levels → 32 runs).

### Fractional Factorial Designs

- Subset of full factorial runs (e.g., ½ fraction of 2³ = 4 runs instead of 8).
- Trade-off: Some interactions are confounded (aliased) with main effects.
- Use case: Screening many factors to identify important ones.

### Response Surface Methodology (RSM)

- Goal: Model curvature (quadratic effects) to find optimal settings.
- Designs: Central Composite Design (CCD), Box-Behnken.
- Example: Optimizing yield by modeling temperature and pressure with quadratic terms.

### Taguchi Methods

- Focus: Robustness to noise (e.g., environmental variability).
- Key idea: Use orthogonal arrays to minimize runs.
- Criticism: Less flexible than classical DoE (fixed designs).

## Steps in a DoE

::: {.r-fit-text}
Be bold, but not stupid
:::

### Define Objectives

- Screening (identify important factors)?
- Optimization (find best settings)?
- Robustness (reduce variability)?


### Select Factors & Levels:

Use subject-matter knowledge or preliminary experiments.


### Choose Design

Full/fractional factorial? RSM? Taguchi?


### Randomize & Run Experiments:

Avoid bias (e.g., time-order effects).


### Analyze Data:

ANOVA, regression, effect plots.


### Interpret & Validate:

- Check assumptions (normality, independence).
- Confirm with follow-up experiments.

## Case Study - The catapult

```{r}
#| include: false

Full_Factorial_Catapult_RunSheet <- vroom(
  here("data","Full_Factorial_Catapult_RunSheet.csv")
  ) 

msa <- vroom(
  here("data","MSA1_DataSheet.csv")
) |> janitor::clean_names()


ff_lng <- Full_Factorial_Catapult_RunSheet |> 
  pivot_longer(
    cols = c("LaunchAngle_deg","RubberBands_count","ArmLength_cm")
  )

ff_rep <- Full_Factorial_Catapult_RunSheet |> 
  select(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands,
    Distance_cm
  ) 

ff <- Full_Factorial_Catapult_RunSheet |> 
  select(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands,
    Distance_cm
  ) |> 
  group_by(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands
  ) |> 
  summarise(
    ybar = mean(Distance_cm),
    ysd = sd(Distance_cm),
    yrange = max(Distance_cm)-min(Distance_cm)
  ) |> 
  ungroup() |> 
  filter(
    A_LaunchAngle != 0
  )

ff_center_rep <- Full_Factorial_Catapult_RunSheet |> 
  select(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands,
    Distance_cm
  ) |> 
  group_by(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands
  ) |> 
  filter(
    A_LaunchAngle == 0
  ) |> 
  add_column(
    center = "center points"
  )

ff_center <- Full_Factorial_Catapult_RunSheet |> 
  select(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands,
    Distance_cm
  ) |> 
  group_by(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands
  ) |> 
  summarise(
    ybar = mean(Distance_cm),
    ysd = sd(Distance_cm),
    yrange = max(Distance_cm)-min(Distance_cm)
  ) |> 
  ungroup() |> 
  filter(
    A_LaunchAngle == 0
  )

ff_real_world <- Full_Factorial_Catapult_RunSheet |> 
  select(
    LaunchAngle_deg,
    RubberBands_count,
    Distance_cm
  ) |> 
  mutate(
    RubberBands_count = as_factor(RubberBands_count)
  )

ff_sd_real_world <- Full_Factorial_Catapult_RunSheet |> 
  group_by(
    LaunchAngle_deg,
    RubberBands_count,
  ) |> 
  mutate(
    RubberBands_count = as_factor(RubberBands_count)
  ) |> 
  summarise(
    ysd = sd(Distance_cm)
  ) 



model <- lm(ybar ~ (A_LaunchAngle+B_ArmLength+C_RubberBands)^3,data=ff)

model_rep <- lm(Distance_cm ~ (A_LaunchAngle+B_ArmLength+C_RubberBands)^3,data=ff_rep)

model_sd <- lm(ysd~(A_LaunchAngle+B_ArmLength+C_RubberBands)^3, data = ff)

model_fin <- lm(ybar~A_LaunchAngle + C_RubberBands + A_LaunchAngle:C_RubberBands, data = ff)

model_sd_fin <- lm(ysd~A_LaunchAngle + B_ArmLength + A_LaunchAngle:B_ArmLength, data = ff)

model_fin_real_world <- lm(Distance_cm ~ LaunchAngle_deg + RubberBands_count + LaunchAngle_deg:RubberBands_count, data = ff_real_world)

model_sd_real_world <- lm(ysd ~ LaunchAngle_deg + RubberBands_count + LaunchAngle_deg:RubberBands_count, data = ff_sd_real_world)

grid_vis <- expand_grid(
  LaunchAngle_deg = seq(15,45,1),
  RubberBands_count = as.factor(seq(2,4))
) |> 
  mutate(
    Distance_cm = predict(model_fin_real_world,cur_data())
  )

grid_vis_sd <- expand_grid(
  LaunchAngle_deg = seq(15,45,1),
  RubberBands_count = as.factor(seq(2,4))
) |> 
  mutate(
    ysd = predict(model_sd_real_world,cur_data())
  )

grid_vis_join <- right_join(
  grid_vis,
  grid_vis_sd
) 

grid_vis_join <- grid_vis_join |>  
  mutate(
    ymin = Distance_cm-ysd,
    ymax = Distance_cm + ysd
  )

pred <- predict(model_fin, newdata = ff_center)

dev_from_linear <- t.test(ff_center_rep$Distance_cm,mu = pred) |> broom::tidy()


```

### Measurement System

#### raw data

```{r}
#| label: fig-msa-run-chart
#| out-width: 95%
#| fig-cap: The MSA run chart.

msa |> 
  ggplot(
    aes(
      x = trial,
      y = tape_reading_cm
    )
  )+
  geom_point()+
  geom_line()+
  geom_hline(
    aes(
      yintercept = mean(tape_reading_cm),
      linetype = "mean"
      ),
    size = 1.5
    )+
  geom_hline(
    aes(
      yintercept = mean(tape_reading_cm)+sd(tape_reading_cm),
      linetype = "+/- sd"
      ),
    size = 1.5
    )+
  geom_hline(
    aes(
      yintercept = mean(tape_reading_cm)-sd(tape_reading_cm),
      linetype = "+/- sd"
      ),
    size = 1.5
    )+
  geom_hline(
    aes(
      yintercept = mean(tape_reading_cm)-sd(tape_reading_cm),
      linetype = "+/- sd"
      ),
    size = 1.5
    )+
  geom_hline(
    aes(
      yintercept = mean(reference_distance_cm),
      linetype = "ref"
    )
  )+
  geom_text_repel(
    aes(
      label = tape_reading_cm
    )
  )+
  labs(
    title = "raw msa data",
    x = "trial no",
    y = "reading",
    linetype = ""
  )+
  theme(
    legend.position = "bottom"
  )

```

#### distribution

```{r}
#| label: fig-msa-qq
#| out-width: 95%
#| fig-cap: qq-plot of results

msa |> 
  ggplot(
    aes(
      sample = tape_reading_cm
    )
  )+
  stat_qq_band()+
  stat_qq_line()+
  stat_qq_point()

```

#### possible tolerance window

```{r}
Cp <- 2

tolerance_window <- 6*Cp*sd(msa$tape_reading_cm) |> round(digits = 1)

```

With a $C_p = 2$ the tolerance window is $\pm`r tolerance_window/2`cm$.

#### systematic error

```{r}

msa_syst_error <- msa |> 
  t_test(tape_reading_cm~1,mu = mean(msa$reference_distance_cm)) 

msa_syst_error |> gt()

```
With a p-value of `r msa_syst_error |> pull(p)` there is a significant systematic error.

```{r}
systematic_error <- round(mean(msa$reference_distance_cm)- mean(msa$tape_reading_cm),digits = 1)

```

\begin{align}
\epsilon_{\text{systematic}} = \text{reference}-\bar{x}_{\text{tape reading}}
\end{align}

The systematic error is $`r systematic_error`cm$.

#### check experiment vs. tolerance window

```{r}
#| label: fig-fac-levels-vs-tol
#| out-width: 95%
#| fig-cap: How good can the factor levels be measured?

ff_tol <- ff |> 
  add_column(
    tolerance_window = tolerance_window
  )

ff_tol <- ff_tol |> 
  mutate(
    factor_level = paste("A:",A_LaunchAngle,"| B:", B_ArmLength,"| C:", C_RubberBands)
  )

ff_tol |> 
  ggplot(
    aes(
      x = factor_level,
      y = ybar
    )
  )+
  geom_crossbar(
    aes(
      ymin = ybar-tolerance_window,
      ymax = ybar+tolerance_window,
      color = "accuracy"
    )
  )+
    geom_errorbar(
    aes(
      ymin = ybar-ysd,
      ymax = ybar + ysd,
      color = "experiment data"
    ),
    width = 0.6,
    size = 1.5
  )+
  geom_point()+
  scale_color_brewer(
    palette = "Dark2"
  )+
  labs(
    title = "accuracy vs. factor levels",
    color = ""
    )+
  coord_flip()+
  theme(
    legend.position = "bottom"
  )

```

### Modeling

#### full model

##### model quality

```{r}
#| label: fig-model-q
#| out-width: 95%
#| fig-cap: Model quality (including repetitions)


gg_lm(
  model_rep,
  which_plots = c(2,6)
  )

```

##### significance

```{r}
#| label: tbl-aov
#| tbl-cap: ANOVA results (full nmodel)

model_rep |> tbl_regression() |> 
  add_glance_table(
    include = c("r.squared","adj.r.squared")
  )|> 
  add_vif()

```


### DoE - main modeling

#### pareto plot

```{r}
#| label: fig-pareto
#| out-width: 95%
#| fig-cap: Pareto plot of parameters

pareto_plot(model)

```

#### half normal plot

```{r}
#| label: fig-half-normal
#| out-width: 95%
#| fig-cap: Half normal plot of parameters

half_normal(
  model,
  method = "Zahn",
  ref_line = TRUE,
  label_active = TRUE,
  margin_errors = TRUE
  )

```

#### Main effect plot

```{r}
#| label: fig-main-effect
#| out-width: 95%
#| fig-cap: Main Effect plot
#| 
main_effects(
  ff,
  response = "ybar",
  exclude_vars = c("ysd","yrange")
)


```


#### Interaction effect plot

```{r}
#| label: fig-interaction-effects
#| out-width: 95%
#| fig-cap: Interaction plot

interaction_effects(
  ff,
  response = "ybar",
  n_columns = 1,
  exclude_vars = c("ysd","yrange")
)


```

### DoE - robust design

#### Pareto plot

```{r}
#| label: fig-sd-pareto
#| out-width: 95%
#| fig-cap: Pareto plot for robust design model

pareto_plot(model_sd)

```

#### Half-normal plot

```{r}
#| label: fig-sd-half-normal
#| out-width: 95%
#| fig-cap: Half-normal plot for robust design model

half_normal(model_sd,
  method = "Zahn",
  ref_line = TRUE,
  label_active = TRUE,
  margin_errors = TRUE)

```

#### Main effect plot

```{r}
#| label: fig-sd-main-effect
#| out-width: 95%
#| fig-cap: Main Effect plot
#| 
main_effects(
  ff,
  response = "ysd",
  exclude_vars = c("ybar","yrange")
)


```


#### Interaction effect plot

```{r}
#| label: fig-sd-interaction-effects
#| out-width: 95%
#| fig-cap: Interaction plot

interaction_effects(
  ff,
  response = "ysd",
  n_columns = 1,
  exclude_vars = c("ybar","yrange")
)


```

### Check for linearity

#### Check center points

```{r}
#| label: fig-center-distribution
#| out-width: 95%
#| fig-cap: Interaction plot

ff_center_rep |> 
  ggplot(
    aes(
      sample = Distance_cm
    )
  )+
  stat_qq_band()+
  stat_qq_line()+
  stat_qq_point()

```

#### Test for linear model

```{r}
#| label: fig-center-dev
#| out-width: 95%
#| fig-cap: Interaction plot


ff_center_rep |> 
  ggplot(
    aes(
      x = center,
      y = Distance_cm
    )
  )+
  geom_boxplot(
    outlier.shape = NA
  )+
  geom_jitter()+
  geom_hline(
    yintercept = pred
  )+
  geom_hline(
    aes(
      yintercept = median(Distance_cm)
    )
  )+
  annotate(
    geom = "segment",
    x = "deviation from\nlinear model",
    xend = "deviation from\nlinear model",
    y = median(ff_center_rep$Distance_cm),
    yend = pred,
    arrow = arrow(angle = 15,ends = "both",type = "closed")
  )

```

With a p value of $`r dev_from_linear |> pull(p.value)|> round(digits = 3)`$ the center points deviate significantly from the linear model by about $`r pred - dev_from_linear |> pull(estimate) |> round(digits = 3)`cm$.

### DoE - final model

#### Parameters - classic model

```{r}
#| label: tbl-fin-doe-dummy
#| tbl-cap: Final DoE Model for Distance (dummy model)


model_fin |> 
  tbl_regression() |> 
  add_glance_table(
    include = c("r.squared","adj.r.squared")
  ) |> 
  add_vif()

```

#### Parameters - robust design model

```{r}
#| label: tbl-fin-sd-dummy
#| tbl-cap: Final DoE Model for robust design (dummy model)

model_sd_fin |> 
  tbl_regression() |> 
  add_glance_table(
    include = c("r.squared","adj.r.squared")
  ) |> 
  add_vif()

```

#### Final Catapult Model

```{r}
#| label: fig-fin-grid-vis
#| out-width: 95%
#| fig-cap: Visualization of final model including robust design

grid_vis_join |> 
  ggplot(
    aes(
      x = LaunchAngle_deg,
    )
  )+
  geom_line(
    aes(
      y = Distance_cm,
      linetype = "mean prediction"
    )
  )+
  geom_line(
    aes(
      y = ymax,
      linetype = "+sd"
    )
  )+
  geom_line(
    aes(
      y = ymin,
      linetype = "-sd"
    )
  )+
  facet_wrap(
    ~RubberBands_count,
    labeller = label_both
    )+
  labs(
    title = "Full DoE Model with robust design",
    x = "Launch Angle in Degree",
    y = "Distance in cm",
    linetype = ""
  )+
  scale_linetype_manual(
    values = c("mean prediction" = "solid","+sd"="dashed","-sd"="dashed")
  )+
  scale_x_continuous(
    expand = c(0,0,0,0),
    breaks = pretty
  )+
  scale_y_continuous(
    breaks = pretty
  )+
  theme(
    legend.position = "bottom"
  )


```

### Fractional Factorial [@Gr_mping_2014]

```{r}
#| include: false

frac_design <- FrF2(
  nfactors = 3,               
  nruns = 4, #2^(3-1)
  factor.names = c("A_LaunchAngle", "B_ArmLength", "C_RubberBands"),
  randomize = FALSE
  # replications = 3,
  # repeat.only = TRUE
)

frac_design_rep <- FrF2(
  nfactors = 3,               
  nruns = 4, #2^(3-1)
  factor.names = c("A_LaunchAngle", "B_ArmLength", "C_RubberBands"),
  randomize = FALSE,
  replications = 2,
  repeat.only = TRUE
)

fractional_runs_w_repetitions <- Full_Factorial_Catapult_RunSheet %>%
  filter(
    (A_LaunchAngle == -1 & B_ArmLength == -1 & C_RubberBands == 1) |  # Run 13
    (A_LaunchAngle == 1 & B_ArmLength == -1 & C_RubberBands == -1) |   # Run 4
    (A_LaunchAngle == -1 & B_ArmLength == 1 & C_RubberBands == -1) |   # Run 15
    (A_LaunchAngle == 1 & B_ArmLength == 1 & C_RubberBands == 1)      # Run 22
  )

frac_runs_single <- fractional_runs_w_repetitions |> 
  filter(Replicate==1) |> 
  select(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands,
    Distance_cm
  ) |> 
  mutate(
    A_LaunchAngle = as_factor(A_LaunchAngle),
    B_ArmLength = as_factor(B_ArmLength),
    C_RubberBands = as_factor(C_RubberBands)
  )

frac_runs_rep <- fractional_runs_w_repetitions |> 
  filter(Replicate==1|Replicate==2) |> 
  select(
    A_LaunchAngle,
    B_ArmLength,
    C_RubberBands,
    Distance_cm
  ) |> 
  mutate(
    A_LaunchAngle = as_factor(A_LaunchAngle),
    B_ArmLength = as_factor(B_ArmLength),
    C_RubberBands = as_factor(C_RubberBands)
  )

frac_design_df <- as.data.frame(frac_design)
frac_design_rep_df <- as.data.frame(frac_design_rep)

jnd <- right_join(
  frac_design_df,
  frac_runs_single
)

jnd_rep <- right_join(
  frac_design_rep_df,
  frac_runs_rep,
  relationship = "many-to-many"
) |> 
  distinct()

response <- jnd |> pull(Distance_cm)
response_rep <- jnd_rep |> pull(Distance_cm)

frac_design_resp <- add.response(frac_design,response = response)
frac_design_rep_resp <- add.response(frac_design_rep,response = response_rep)

MEPlot(frac_design_resp)
MEPlot(frac_design_rep_resp)

frac_design_resp_df <- frac_design_resp |> 
  as.data.frame() |> 
  mutate(
    A_LaunchAngle = as.numeric(as.character(A_LaunchAngle)),
    B_ArmLength = as.numeric(as.character(B_ArmLength)),
    C_RubberBands = as.numeric(as.character(C_RubberBands))
  )

frac_design_rep_resp_df <- frac_design_rep_resp |> 
  as.data.frame() |> 
  mutate(
    A_LaunchAngle = as.numeric(as.character(A_LaunchAngle)),
    B_ArmLength = as.numeric(as.character(B_ArmLength)),
    C_RubberBands = as.numeric(as.character(C_RubberBands))
  )

summary(lm(response_rep ~ (A_LaunchAngle + B_ArmLength + C_RubberBands)^2, data = frac_design_rep_resp_df))

main_effects(
  frac_design_resp_df,
  response = "response",
  n_columns = 1
)

interaction_effects(
  frac_design_resp_df,
  response = "response",
  n_columns = 1
)

# main_effects(
#   frac_design_rep_resp_df,
#   response = "response",
#   n_columns = 1
# )


```

Goal: Identify main effects and key interaction with fewer experiments

#### Experimental plan

Original: $2^3 \text{(factor levels)}* 3 \text{(repetitions)} + 6\text{(center points)} = 30 \text{ experiments}$

Fractional (minimal): $2^{3-1} \text{(factor levels)}* 1 \text{(no repetitions)} + 0\text{(center points)} = 4 \text{ experiments}$

#### Aliasing

```{r}
#| label: fig-conf-comparison
#| out-width: 95%
#| fig-cap: What is confounding?

plt_alias_full <- alias_matrix(ff |> select(A_LaunchAngle,B_ArmLength,C_RubberBands))

plt_alias_frac <- alias_matrix(frac_design) 
             
combined <-  plt_alias_full/plt_alias_frac&theme(legend.position = "bottom")

combined

```



#### Confounding

```{r}
#| label: tbl-conf
#| tbl-cap: Example calculation to show what confounding means

frac_design_df_conf <- frac_design_df |> 
  mutate(
    confounding = as.numeric(as.character(B_ArmLength))*as.numeric(as.character(C_RubberBands))
  )

frac_design_df_conf |>     
  gt() |> 
  cols_label(
    A_LaunchAngle = "A: Launch Angle",
    B_ArmLength = "B: Arm Length",
    C_RubberBands = "C: Rubber Bands",
    confounding = "A = B:C"
  )


```

#### Resolution

- degree of confounding (or aliasing)
- provides a way to classify designs based on how severely factors and interactions are confounded
- Higher resolution means less confounding and more reliable estimation of effects
  - III: Main effects are confounded with two-way interactions
  - IV: Main effects are confounded with three-way (or higher) interactions, but two-way interactions are confounded with each other
  - V: Main effects and two-way interactions are confounded only with three-way (or higher) interactions.
  
#### practical implications

- Lower resolution (e.g., R-III): Cheaper (fewer runs) but riskier because main effects may be confounded with two-way interactions. 

**If interactions exist, you might misinterpret the results.**

- Higher resolution (e.g., R-V): More expensive (more runs) but provides clearer estimates of main effects and two-way interactions. 

**Preferred when interactions are suspected or critical.**

#### available designs and resoultion

```{r}

catlg_df <- data.frame(
  nfac = nfac(
    catlg = catlg
    ),
  nruns = nruns(
    catlg = catlg
  ),
  res = res(
    catlg = catlg
  )
) |> 
  filter(
    nruns>4,
    nfac<25,
    nruns<129
  ) |> 
  group_by(
    nruns,
    nfac
  ) |> 
  summarise(
    res = max(res)
  ) |> 
  ungroup() |> 
  add_row(
    nfac = c(3,3,3,3,3,4,4,4,4,5,5,5,6,6,7),
    nruns = c(8,16,32,64,128,16,32,64,128,32,64,128,64,128,128),
    res = c(9,10,10,10,10,9,10,10,10,9,10,10,9,10,9)
  ) |> 
  mutate(
    roman_res = case_when(
      res==3~"III",
      res==4~"IV",
      res==5~"V",
      res==6~"VI",
      res==7~"VII",
      res==8~"VIII",
      res==9~"full",
      res>9~" ",
    )
  )




catlg_df |> ggplot(
  aes(
    x = as_factor(nruns),
    y = as_factor(nfac),
    fill = as_factor(roman_res),
    label = roman_res
    )
  )+
  geom_tile(
    color = "white",
    show.legend = FALSE
  )+
  geom_text()+
  scale_y_discrete(
    limits = rev,
    expand = c(0,0,0,0)
  )+
  scale_x_discrete(
    expand = c(0,0,0,0)
  )+
  scale_fill_manual(
    values = 
     c(
       "III" = "firebrick", 
       "IV" = "gold", 
       "V" = "darkgreen",
       "VI" = "darkgreen",
       "VII" = "darkgreen",
       "VIII" = "darkgreen",
       "full" = "darkgreen",
       " " = "darkgreen"
       )
  )+
  labs(
    title = "Design and resolution",
    x = "number of runs",
    y = "number of factors"
  )+
  theme(
    legend.position = "bottom",
    panel.border = element_blank()
  )

```


::: {.content-visible when-profile="slides"}

## References

::: {#refs}

:::

:::